# Xargs command usage:

Xargs is used to build and execute command lines from standard input.
It is particularly useful when you want to apply a command to a list of items generated by other commands.

**Syntax:**
  `command | xargs [options] [command [initial-arguments]]`

**Example:**
List of file names and you want to delete them using the rm command.
  `ls *.txt | xargs rm`

# Options:
## -n, --max-args=MAX-ARGS:
Specify the maximum number of arguments that `xargs` will pass to the command.
This is useful if you want to process a certain number of arguments at a time.

**Example:**
Group `ls` command output to 1 argument at each instance:
  ```$ ls Makefile.arm | xargs -n 1
    -rw-rw-r--.
    1
    user
    user
    490
    Feb
    23
    13:41
    Makefile.arm```

Group `ls` command output to 2 argument at each instance:
  ```$ ls Makefile.arm | xargs -n 2
    -rw-rw-r--. 1
    user user
    490 Feb
    23 13:41
    Makefile.arm```

## -I, --replace[=REPLACE-STR]:
Replace occurrences of `REPLACE-STR` in the initial-arguments with names read from the input source.
Allows to use `{}` as a placeholder for each file name in the command constructed by xargs.

**Example 1:**
Xargs command specifies a placeholder `{}` that will be replaced by the `@arguments` coming from the input.
  `echo "file1.txt file2.txt" | xargs -I {} mv {} /path/to/destination`

**Example 2:**
Replace the string 'XX' with the input arguments of the Xargs:
Here 'XX' is replaced by the `ls` output (Makefile).
```  ls Makefile | xargs -I XX echo [ XX ]
  [ Makefile ]
```
## -a, --arg-file=FILE:
Read arguments from a file instead of standard input.
  `xargs -a file_list.txt rm`

## -p, --interactive:
Prompt before executing each command.
  `find . -name "*.log" | xargs -p rm`

## -r, --no-run-if-empty:
Do not run the command if there are no arguments.
  `find . -name "*.tmp" | xargs -r rm`

# Use cases:
List of files and move them to a specific directory:
  `ls *.txt | xargs -I {} mv {} /path/to/destination`

Find files matching a certain pattern and print them with colors as ls does:
  `find /path/to/search -type f -name "pattern" | xargs ls --color=always`

Conditional statement in xargs:
  `find /path/to/search -type f -name "pattern" -o -type d -name "pattern" | xargs -I {} bash -c 'if [ -d "{}" ]; then ls -d --color "{}"; else ls --color "{}"; fi'`
